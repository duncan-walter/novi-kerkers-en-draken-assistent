// Styling
import './CharacterDetails.css';

// Icons
import {PencilIcon} from "@phosphor-icons/react";

// Framework dependencies
import {useEffect, useState} from "react";
import {useParams} from "react-router-dom";

// Custom hooks
import useRequestState from "../../../hooks/useRequestState.js";
import {useToaster} from "../../../contexts/ToasterContext.jsx";

// Services
import characterService from "../../../services/characterService.js";
import characterPossessionsService from "../../../services/characterPossessionsService.js";

// Helpers and constants
import mapFormKeysToAPIKeys from "../../../helpers/mapFormKeysToAPIKeys.js";
import {removeLocalStorageItem} from "../../../helpers/localStorageHelpers.js";
import {charactersKey} from "../../../constants/localStorageKeys.js";

// Components
import Panel from "../../../components/ui/Panel/Panel.jsx";
import Button from "../../../components/ui/Button/Button.jsx";
import Spinner from "../../../components/ui/Spinner/Spinner.jsx";
import CharacterForm from "../../../components/forms/CharacterForm/CharacterForm.jsx";

function CharacterDetails() {
  const [mode, setMode] = useState('read');
  const [initialValues, setInitialValues] = useState(null);

  const params = useParams();
  const {showToast} = useToaster();

  // Get character
  const {
    data: character,
    loading: getCharacterLoading,
    error: getCharacterError,
    executeRequest: getCharacter
  } = useRequestState(
    characterService.getCharacterById(params.id, {useCache: true}),
    {
      executeOnMount: false,
      isAbortable: true
    }
  );
  // Get character possessions
  const {
    data: characterPossessions,
    loading: getCharacterPossessionsLoading,
    error: getCharacterPossessionsError,
    executeRequest: getCharacterPossessions
  } = useRequestState(
    characterPossessionsService.getCharacterPossessionsById(params.id, {useCache: true}),
    {
      executeOnMount: false,
      isAbortable: true
    }
  );
  // Update character
  const {
    data: updatedCharacter,
    statusCode: updateCharacterStatusCode,
    loading: updateCharacterLoading,
    error: updateCharacterError,
    executeRequest: updateCharacter
  } = useRequestState(
    characterService.updateCharacter,
    {
      executeOnMount: false,
      isAbortable: false
    }
  );

  // Character possessions are not updated because of a bug in the NOVI Backend API. The API can generate duplicate ids.
  const handleUpdateSubmit = async (characterFormData) => {
    mapFormKeysToAPIKeys(characterFormData, 'characterForm');

    // Character possessions are deleted before sending the update character request to prevent sending data that is not used.
    if (characterFormData.characterPossessions) {
      delete characterFormData.characterPossessions;
    }

    const updatedCharacter = await updateCharacter(characterFormData);

    // Manually invalidate characters cache and retrieve data again
    removeLocalStorageItem(charactersKey);
    removeLocalStorageItem(`${charactersKey}/${updatedCharacter.id}`);
    await getCharacter();
    await getCharacterPossessions();
    setMode('read');
  }

  const handleUpdateCancel = () => {
    setMode('read');
  }

  // Generic error from useRequestState.
  useEffect(() => {
    [getCharacterError, getCharacterPossessionsError, updateCharacterError].forEach(error => {
      if (error) {
        showToast(error, 'error');
      }
    });
  }, [getCharacterError, getCharacterPossessionsError, updateCharacterError]);

  // Toast messages after update.
  useEffect(() => {
    if (updateCharacterStatusCode) {
      switch (updateCharacterStatusCode) {
        case 200:
          showToast(`${updatedCharacter.name} is klaar voor een nieuw hoofdstuk!`, 'success');
          break;
        case 401:
          showToast('Onbekende reiziger, toegang geweigerd.', 'error');
          break;
        case 403:
          showToast('De wachters erkennen je rang niet als voldoende.', 'error');
          break;
        case 406:
          showToast('Als je dit ziet heeft Duncan zijn intelligence check gefaald.', 'error');
          break;
        case 500:
        default:
          showToast('Een mysterieuze storing blokkeert je pad.', 'error');
          break;
      }
    }
  }, [updateCharacterStatusCode])

  // Get character and it's possessions when the id parameter is ready.
  useEffect(() => {
    if (params.id) {
      getCharacter();
      getCharacterPossessions();
    }
  }, [params.id])

  useEffect(() => {
    if (!getCharacterLoading && !getCharacterPossessionsLoading && character && characterPossessions) {
      // Because duplicate ids are generated by the backend the index is temporarily used to be able to render the possessions.
      // In a normal situation the id will be used of course.
      const adjustedCharacterPossessions = Object.fromEntries(
        characterPossessions.map((possession, index) => [index, possession.name])
      );

      setInitialValues({...character, characterPossessions: adjustedCharacterPossessions});
    }
  }, [character, characterPossessions]);

  return (
    <Panel
      title={getCharacterLoading ? '' : character?.name}
      panelButton={mode === 'read' ?
        <Button
          label="Personage aanpassen"
          icon={PencilIcon}
          onClick={() => setMode('edit')}
        /> : null
      }
    >
      {getCharacterLoading || getCharacterPossessionsLoading ? (
        <div className="character-details__loading">
          <Spinner size='large'/>
        </div>
      ) : mode === 'edit' ? (
        <CharacterForm
          initialValues={initialValues}
          onSubmit={handleUpdateSubmit}
          onCancel={handleUpdateCancel}
          loading={updateCharacterLoading}
        />
      ) : mode === 'read' && character ? (
        Object.entries(character).map(([key, value], index) => <p key={index}>{key}: {value}</p>)
      ) : null}
    </Panel>
  )
}

export default CharacterDetails;